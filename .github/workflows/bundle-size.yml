# ═══════════════════════════════════════════════════════════════════════════════
# Bundle Size Guard — Prevent silent frontend bloat
# ═══════════════════════════════════════════════════════════════════════════════
# Measures Next.js production bundle sizes on every PR and compares against
# the baseline from main. Posts a size report as a PR comment and FAILS the
# build if total JS shipped to the client exceeds the hard threshold.
#
# Why: Next.js bundles grow silently. A new dependency or unguarded dynamic
# import can add 50-200 KB without anyone noticing until Lighthouse scores
# drop. This gate catches it at PR time.
#
# Thresholds:
#   WARN:  +5% total JS size increase vs baseline
#   FAIL:  +15% total JS size increase vs baseline  OR  > 4000 KB total JS
#
# The baseline is captured from the main branch build. PR builds are compared.
# ═══════════════════════════════════════════════════════════════════════════════

name: Bundle Size Guard

on:
  pull_request:
    branches: [main]
    paths:
      - "frontend/**"

permissions:
  contents: read
  pull-requests: write # Required to post size comment

concurrency:
  group: bundle-size-${{ github.event.pull_request.number }}
  cancel-in-progress: true

env:
  # Hard limits — adjust as codebase evolves
  TOTAL_BUNDLE_LIMIT_KB: 4000 # Absolute cap on total JS shipped (KB)
  TOTAL_SIZE_WARN_PCT: 5 # Warn if total increases by this %
  TOTAL_SIZE_FAIL_PCT: 15 # Fail if total increases by this %

jobs:
  # ─────────────────────────────────────────────────────────────────────────
  # Build main baseline (cached aggressively)
  # ─────────────────────────────────────────────────────────────────────────
  baseline:
    name: Build Baseline (main)
    runs-on: ubuntu-latest
    timeout-minutes: 8
    defaults:
      run:
        working-directory: frontend

    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          ref: main

      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: frontend/package-lock.json

      - run: npm ci

      - name: Cache Next.js build (main)
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: frontend/.next/cache
          key: next-baseline-${{ runner.os }}-${{ hashFiles('frontend/package-lock.json') }}

      - name: Build main
        run: npx next build
        timeout-minutes: 5
        env:
          # Skip Sentry upload for baseline — we only need sizes
          SENTRY_AUTH_TOKEN: ""

      - name: Extract bundle sizes
        run: |
          # Next.js writes route manifest with sizes to .next/routes-manifest.json
          # and build output to stdout. We'll parse the build output.
          node -e "
            const fs = require('fs');
            const manifest = JSON.parse(fs.readFileSync('.next/build-manifest.json', 'utf8'));

            // Collect all unique JS chunks from Pages Router
            const chunks = new Set();
            for (const [route, files] of Object.entries(manifest.pages || {})) {
              for (const file of files) {
                if (file.endsWith('.js')) chunks.add(file);
              }
            }

            // Also collect App Router chunks (Next.js 13+/15)
            try {
              const appManifest = JSON.parse(fs.readFileSync('.next/app-build-manifest.json', 'utf8'));
              for (const [route, entry] of Object.entries(appManifest.pages || {})) {
                for (const file of entry) {
                  if (typeof file === 'string' && file.endsWith('.js')) chunks.add(file);
                }
              }
            } catch {}

            // Measure total size of unique JS files
            let totalBytes = 0;
            const sizes = {};
            for (const chunk of chunks) {
              try {
                const stat = fs.statSync('.next/' + chunk);
                sizes[chunk] = stat.size;
                totalBytes += stat.size;
              } catch {}
            }

            const report = {
              totalBytes,
              totalKB: Math.round(totalBytes / 1024),
              chunkCount: chunks.size,
              routeCount: Object.keys(manifest.pages || {}).length,
            };

            fs.writeFileSync('../baseline-sizes.json', JSON.stringify(report, null, 2));
            console.log('Baseline:', JSON.stringify(report));
          "

      - name: Upload baseline
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: bundle-baseline
          path: baseline-sizes.json
          retention-days: 1

  # ─────────────────────────────────────────────────────────────────────────
  # Build PR and compare
  # ─────────────────────────────────────────────────────────────────────────
  compare:
    name: Compare Bundle Size
    runs-on: ubuntu-latest
    needs: baseline
    timeout-minutes: 8
    defaults:
      run:
        working-directory: frontend

    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: frontend/package-lock.json

      - run: npm ci

      - name: Cache Next.js build (PR)
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: frontend/.next/cache
          key: next-pr-${{ github.event.pull_request.number }}-${{ hashFiles('frontend/package-lock.json') }}-${{ hashFiles('frontend/src/**') }}
          restore-keys: |
            next-pr-${{ github.event.pull_request.number }}-${{ hashFiles('frontend/package-lock.json') }}-
            next-pr-${{ github.event.pull_request.number }}-

      - name: Build PR
        run: npx next build
        timeout-minutes: 5
        env:
          SENTRY_AUTH_TOKEN: ""

      - name: Download baseline
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4
        with:
          name: bundle-baseline
          path: .

      - name: Compare and report
        id: compare
        run: |
          node -e "
            const fs = require('fs');

            // Parse PR sizes
            const manifest = JSON.parse(fs.readFileSync('.next/build-manifest.json', 'utf8'));
            const chunks = new Set();
            for (const [route, files] of Object.entries(manifest.pages || {})) {
              for (const file of files) {
                if (file.endsWith('.js')) chunks.add(file);
              }
            }

            // Also collect App Router chunks (Next.js 13+/15)
            try {
              const appManifest = JSON.parse(fs.readFileSync('.next/app-build-manifest.json', 'utf8'));
              for (const [route, entry] of Object.entries(appManifest.pages || {})) {
                for (const file of entry) {
                  if (typeof file === 'string' && file.endsWith('.js')) chunks.add(file);
                }
              }
            } catch {}

            let totalBytes = 0;
            for (const chunk of chunks) {
              try {
                const stat = fs.statSync('.next/' + chunk);
                totalBytes += stat.size;
              } catch {}
            }
            const prKB = Math.round(totalBytes / 1024);

            // Parse baseline
            const baseline = JSON.parse(fs.readFileSync('../baseline-sizes.json', 'utf8'));
            const baseKB = baseline.totalKB;
            const diffKB = prKB - baseKB;
            const diffPct = baseKB > 0 ? ((diffKB / baseKB) * 100).toFixed(1) : 0;

            const warnPct = Number(process.env.TOTAL_SIZE_WARN_PCT);
            const failPct = Number(process.env.TOTAL_SIZE_FAIL_PCT);
            const totalLimit = Number(process.env.TOTAL_BUNDLE_LIMIT_KB);

            let status = '✅';
            let exitCode = 0;
            if (Math.abs(diffPct) >= failPct) {
              status = '❌';
              exitCode = 1;
            } else if (Math.abs(diffPct) >= warnPct) {
              status = '⚠️';
            }

            // Absolute cap on total bundle size
            if (prKB > totalLimit) {
              status = '❌';
              exitCode = 1;
            }

            const sign = diffKB >= 0 ? '+' : '';
            const report = [
              '## Bundle Size Report',
              '',
              '| Metric | Value |',
              '|--------|-------|',
              '| Main baseline | **' + baseKB + ' KB** |',
              '| This PR | **' + prKB + ' KB** |',
              '| Delta | ' + status + ' **' + sign + diffKB + ' KB** (' + sign + diffPct + '%) |',
              '| JS chunks | ' + chunks.size + ' |',
              '| Hard limit | ' + totalLimit + ' KB |',
              '',
              exitCode ? '❌ **Bundle size exceeds threshold. Please investigate.**' : '✅ Bundle size is within acceptable limits.',
            ].join('\n');

            // Write to step summary
            fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, report + '\n');

            // Write comment body for PR
            fs.writeFileSync('../bundle-comment.md', report);

            // Signal exit code
            fs.writeFileSync('../bundle-exit-code.txt', String(exitCode));

            console.log(report);
          "

      - name: Post PR comment
        if: ${{ !cancelled() && github.event.pull_request.head.repo.fork != true }}
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7
        with:
          script: |
            const fs = require('fs');
            const body = fs.readFileSync('bundle-comment.md', 'utf8');
            const marker = '<!-- bundle-size-guard -->';
            const fullBody = marker + '\n' + body;

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              ...context.repo,
              issue_number: context.issue.number,
            });
            const existing = comments.find(c => c.body?.includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                ...context.repo,
                comment_id: existing.id,
                body: fullBody,
              });
            } else {
              await github.rest.issues.createComment({
                ...context.repo,
                issue_number: context.issue.number,
                body: fullBody,
              });
            }

      - name: Enforce threshold
        run: |
          exit_code=$(cat ../bundle-exit-code.txt 2>/dev/null || echo "0")
          if [ "$exit_code" -ne 0 ]; then
            echo "::error::Bundle size exceeds threshold — see report above."
            exit 1
          fi
