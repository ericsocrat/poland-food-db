name: QA Tests

on:
  push:
    branches: [main]
    paths:
      - "db/**"
      - "supabase/**"
      - "pipeline/**"
      - "RUN_QA.ps1"
      - "RUN_LOCAL.ps1"
      - "RUN_SEED.ps1"
      - "RUN_SANITY.ps1"
      - "validate_eans.py"
      - "enrich_ingredients.py"
      - "check_enrichment_identity.py"
      - "check_pipeline_structure.py"
      - "fetch_off_category.py"
      - ".github/workflows/qa.yml"
  pull_request:
    branches: [main]
    paths:
      - "db/**"
      - "supabase/**"
      - "pipeline/**"
      - "validate_eans.py"
      - "enrich_ingredients.py"
      - "check_enrichment_identity.py"
      - "check_pipeline_structure.py"
      - "fetch_off_category.py"
      - "RUN_QA.ps1"
      - "RUN_LOCAL.ps1"
      - "RUN_SEED.ps1"
      - "RUN_SANITY.ps1"
      - ".github/workflows/qa.yml"
  workflow_dispatch:
    inputs:
      fail_on_warn:
        description: "Treat informational warnings as failures"
        required: false
        type: boolean
        default: false

permissions:
  contents: read

concurrency:
  group: qa-${{ github.event.pull_request.number || github.sha }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:
  qa:
    name: DB Integrity
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 10

    services:
      postgres:
        image: postgres:17
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres # NOSONAR — ephemeral CI-only container
          POSTGRES_DB: postgres
        ports:
          - 54322:5432
        options: >-
          --health-cmd="pg_isready -U postgres"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=5

    env:
      PGHOST: localhost
      PGPORT: 54322
      PGUSER: postgres
      PGPASSWORD: postgres # NOSONAR — ephemeral CI-only container
      PGDATABASE: postgres

    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Set up Python
        uses: actions/setup-python@a309ff8b426b58ec0e2a45f0f869d46889d02405 # v6.2.0
        with:
          python-version: "3.12"
          cache: "pip"

      - name: Install Python dependencies
        run: pip install -r requirements.txt

      - name: Enrichment identity guard
        run: |
          set -euo pipefail
          python check_enrichment_identity.py

      - name: Pipeline structure guard
        run: |
          set -euo pipefail
          python check_pipeline_structure.py

      - name: Apply schema migrations
        run: |
          set -euo pipefail
          for f in $(ls supabase/migrations/*.sql | sort); do
            echo "Applying: $f"
            psql -v ON_ERROR_STOP=1 -f "$f"
          done

      - name: Run pipelines
        run: |
          set -euo pipefail
          for category in db/pipelines/*/; do
            cat_name=$(basename "$category")
            for f in $(ls "$category"PIPELINE__*.sql 2>/dev/null | sort); do
              echo "  RUN  $f"
              psql -v ON_ERROR_STOP=1 -f "$f"
            done
          done

      - name: Replay enrichment data
        run: |
          set -euo pipefail
          # Enrichment migrations run BEFORE pipelines, so their JOINs on
          # products(country, ean) match zero rows.  Re-run them now that
          # pipelines have populated the products table.
          #
          # PL enrichment: safe — resolves product_id + ingredient_id via JOINs
          # DE enrichment: ingredient_ids are hardcoded but deterministic (same
          #   serial values from identical migration ordering)
          # Both use ON CONFLICT DO NOTHING — fully idempotent.
          #
          # The allergen FK constraint (fk_allergen_tag_ref) must be dropped
          # before replay because the enrichment files use raw en:-prefixed tags.
          # ci_normalize_allergens.sql re-normalizes and re-adds the FK.

          echo "Dropping allergen FK for enrichment replay..."
          psql -v ON_ERROR_STOP=1 -c \
            "ALTER TABLE product_allergen_info DROP CONSTRAINT IF EXISTS fk_allergen_tag_ref;"

          echo "Replaying PL enrichment (20260215141000)..."
          psql -v ON_ERROR_STOP=1 -f supabase/migrations/20260215141000_populate_ingredients_allergens.sql

          echo "Replaying DE enrichment (20260309000100)..."
          psql -v ON_ERROR_STOP=1 -f supabase/migrations/20260309000100_de_enrichment_ingredients_allergens.sql

          echo "Normalizing allergen tags and re-adding FK..."
          psql -v ON_ERROR_STOP=1 -f db/ci_normalize_allergens.sql

          echo "Computing concern scores and re-scoring all categories..."
          psql -v ON_ERROR_STOP=1 -f db/ci_post_enrichment.sql

          echo "Enrichment replay complete."
          # Verify data arrived
          counts=$(psql --tuples-only --no-align -c "
            SELECT 'product_ingredient=' || (SELECT count(*) FROM product_ingredient)
                || ' product_allergen_info=' || (SELECT count(*) FROM product_allergen_info)
                || ' ingredient_ref=' || (SELECT count(*) FROM ingredient_ref);
          ")
          echo "Enrichment row counts: $counts"

      - name: Schema drift detection
        run: |
          set -euo pipefail
          # Verify there are no unexpected test functions left in public schema.
          # (The table subquery comparing pg_tables vs information_schema was a
          #  no-op: both catalog views show the same rows. Removed in CI noise
          #  reduction pass.)
          orphans=$(psql --tuples-only --no-align -c "
            SELECT 'FUNCTION: ' || routine_name FROM information_schema.routines
            WHERE routine_schema = 'public'
              AND routine_type = 'FUNCTION'
              AND routine_name LIKE 'test_%'
          " 2>&1 || true)
          orphans_trimmed=$(echo "$orphans" | sed '/^$/d')
          if [ -n "$orphans_trimmed" ]; then
            echo "::warning::Potential schema drift detected:"
            echo "$orphans_trimmed"
          else
            echo "✓ No schema drift detected"
          fi

      - name: Post-pipeline fixup
        run: |
          set -euo pipefail
          echo "Applying CI post-pipeline fixup..."
          psql -v ON_ERROR_STOP=1 -f db/ci_post_pipeline.sql
          echo "Post-pipeline fixup complete."

      - name: Scoring diagnostic
        if: always()
        run: |
          echo "=== Anchor product scores ==="
          psql --tuples-only -c "
            SELECT p.product_id, p.brand, p.product_name, p.category, p.country,
                   p.unhealthiness_score, p.ingredient_concern_score, p.controversies,
                   (SELECT COUNT(*) FROM product_ingredient pi WHERE pi.product_id = p.product_id) AS pi_count,
                   (SELECT COUNT(*) FILTER (WHERE ir2.is_additive)
                    FROM product_ingredient pi2
                    JOIN ingredient_ref ir2 ON ir2.ingredient_id = pi2.ingredient_id
                    WHERE pi2.product_id = p.product_id) AS additive_count
            FROM products p
            WHERE (p.product_name = 'Doriros Sweet Chili Flavoured 100g' AND p.brand = 'Doritos')
               OR (p.product_name = 'Coca-Cola Zero' AND p.country = 'DE')
               OR (p.product_name = 'Tortilla Pszenno-Żytnia' AND p.brand = 'Auchan')
               OR (p.product_name = 'Czekolada Tiramisu' AND p.brand = 'E. Wedel')
               OR (p.product_name = 'Noodles Chicken Flavour' AND p.brand = 'Indomie')
            ORDER BY p.product_name;
          "

      - name: Run QA via RUN_QA.ps1
        id: qa
        shell: pwsh
        run: |
          $failOnWarn = '${{ inputs.fail_on_warn }}' -eq 'true'
          if ($failOnWarn) {
            & ./RUN_QA.ps1 -Json -OutFile qa.json -FailOnWarn
          } else {
            & ./RUN_QA.ps1 -Json -OutFile qa.json
          }
          $exitCode = $LASTEXITCODE
          # Write exit code for downstream steps
          "qa_exit_code=$exitCode" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          # Don't fail yet — let summary + artifact steps run
          if ($exitCode -ne 0) {
            Write-Host "::warning::QA exited with code $exitCode"
          }

      - name: Upload QA results
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: qa-results
          path: qa.json
          retention-days: 30

      - name: Run sanity checks
        shell: pwsh
        run: |
          & ./RUN_SANITY.ps1 -Env local -Json -OutFile sanity.json
          $exitCode = $LASTEXITCODE
          if ($exitCode -ne 0) {
            Write-Host "::warning::Sanity checks exited with code $exitCode"
          }

      - name: Upload sanity results
        if: always()
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: sanity-results
          path: sanity.json
          retention-days: 30
          if-no-files-found: ignore

      - name: Confidence coverage threshold
        run: |
          # Fail if more than 5% of products have low confidence
          # Note: CI threshold is 5% (not 1%) because data-enrichment migrations
          # use hardcoded product_ids and don't populate ingredient/allergen data,
          # artificially deflating confidence scores.
          low_count=$(psql --tuples-only -c "
            SELECT COUNT(*) FROM v_product_confidence WHERE confidence_band = 'low';
          " 2>&1 | tr -d ' ')
          total=$(psql --tuples-only -c "
            SELECT COUNT(*) FROM products WHERE is_deprecated IS NOT TRUE;
          " 2>&1 | tr -d ' ')
          # Integer math: threshold = total * 5 / 100 (5% floor division)
          threshold=$((total * 5 / 100))
          echo "Low confidence: $low_count / $total (threshold: $threshold)"
          if [ "$low_count" -gt "$threshold" ]; then
            echo "✗ FAILED — More than 5% of products have low confidence ($low_count / $total)"
            exit 1
          else
            echo "✓ PASS — Low confidence within threshold"
          fi

      - name: Generate QA summary
        if: always()
        shell: pwsh
        run: |
          if (-not (Test-Path 'qa.json')) {
            "## QA Summary`n`n:x: qa.json not found — QA step may have failed to start." | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append
            exit 0
          }
          $qa = Get-Content 'qa.json' -Raw | ConvertFrom-Json
          $sb = [System.Text.StringBuilder]::new()
          [void]$sb.AppendLine("## QA Summary")
          [void]$sb.AppendLine("")
          [void]$sb.AppendLine("| Suite | ID | Checks | Status | Runtime |")
          [void]$sb.AppendLine("|-------|----|--------|--------|---------|")
          foreach ($s in $qa.suites) {
            $icon = switch ($s.status) {
              'pass' { ':white_check_mark:' }
              'fail' { ':x:' }
              'warn' { ':warning:' }
              'error' { ':boom:' }
              default { ':grey_question:' }
            }
            $rt = if ($s.runtime_ms) { "$($s.runtime_ms) ms" } else { '—' }
            [void]$sb.AppendLine("| $($s.name) | ``$($s.suite_id)`` | $($s.checks) | $icon $($s.status) | $rt |")
          }
          [void]$sb.AppendLine("")
          [void]$sb.AppendLine("**Overall: $($qa.overall)** — $($qa.summary.passed) passed, $($qa.summary.failed) failed, $($qa.summary.warnings) warnings")
          [void]$sb.AppendLine("")
          [void]$sb.AppendLine("*Schema version: $($qa.version) · Timestamp: $($qa.timestamp)*")
          $sb.ToString() | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append

      - name: Fail if QA failed
        if: always()
        shell: pwsh
        run: |
          if (-not (Test-Path 'qa.json')) { exit 1 }
          $qa = Get-Content 'qa.json' -Raw | ConvertFrom-Json
          if ($qa.overall -eq 'fail') {
            Write-Host "::error::QA FAILED — $($qa.summary.failed) check(s) failed"
            exit 1
          }
          if ($qa.overall -eq 'warn') {
            Write-Host "::warning::QA passed with warnings ($($qa.summary.warnings) flagged items)"
            # Only fail on warn if explicitly requested
            $failOnWarn = '${{ inputs.fail_on_warn }}' -eq 'true'
            if ($failOnWarn) { exit 2 }
          }
          Write-Host "QA passed: $($qa.summary.passed)/$($qa.summary.total_checks) checks"
