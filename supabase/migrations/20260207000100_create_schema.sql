


SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


COMMENT ON SCHEMA "public" IS 'standard public schema';

CREATE SCHEMA IF NOT EXISTS "extensions";
CREATE SCHEMA IF NOT EXISTS "auth";

CREATE OR REPLACE FUNCTION auth.uid()
RETURNS uuid
LANGUAGE sql
STABLE
AS $$
    SELECT NULL::uuid;
$$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'anon') THEN
        CREATE ROLE anon NOLOGIN;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'authenticated') THEN
        CREATE ROLE authenticated NOLOGIN;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_roles WHERE rolname = 'service_role') THEN
        CREATE ROLE service_role NOLOGIN;
    END IF;
END
$$;



DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM pg_available_extensions WHERE name = 'pg_graphql'
    ) THEN
        CREATE SCHEMA IF NOT EXISTS graphql;
        CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";
    END IF;
END
$$;






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM pg_available_extensions WHERE name = 'supabase_vault'
    ) THEN
        CREATE SCHEMA IF NOT EXISTS vault;
        CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";
    END IF;
END
$$;






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";





SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."ingredients" (
    "product_id" bigint NOT NULL,
    "ingredients_raw" "text",
    "additives_count" "text"
);


ALTER TABLE "public"."ingredients" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."nutrition_facts" (
    "product_id" bigint NOT NULL,
    "serving_id" bigint NOT NULL,
    "calories" "text",
    "total_fat_g" "text",
    "saturated_fat_g" "text",
    "trans_fat_g" "text",
    "carbs_g" "text",
    "sugars_g" "text",
    "fibre_g" "text",
    "protein_g" "text",
    "salt_g" "text",
    "cholesterol_mg" "text",
    "potassium_mg" "text"
);


ALTER TABLE "public"."nutrition_facts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."products" (
    "product_id" bigint NOT NULL,
    "country" "text" DEFAULT 'PL'::"text" NOT NULL,
    "brand" "text",
    "product_type" "text",
    "category" "text",
    "product_name" "text" NOT NULL,
    "aluminium_based_additives" "text",
    "oil_method" "text",
    "ingredient_complexity" "text",
    "controversies" "text",
    "eu_notes" "text",
    "is_deprecated" boolean DEFAULT false,
    "deprecated_reason" "text"
);


ALTER TABLE "public"."products" OWNER TO "postgres";


ALTER TABLE "public"."products" ALTER COLUMN "product_id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."products_product_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."scores" (
    "product_id" bigint NOT NULL,
    "unhealthiness_score" "text",
    "healthiness_score" "text",
    "nutri_score_label" "text",
    "processing_risk" "text",
    "nova_classification" "text",
    "high_salt_flag" "text",
    "high_sugar_flag" "text",
    "high_sat_fat_flag" "text",
    "high_additive_load" "text",
    "scoring_version" "text",
    "scored_at" "date",
    "data_completeness_pct" numeric,
    "confidence" "text",
    "personal_unhealthiness_balanced" numeric,
    "personal_unhealthiness_low_salt" numeric,
    "personal_unhealthiness_low_sugar" numeric
);


ALTER TABLE "public"."scores" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."servings" (
    "serving_id" bigint NOT NULL,
    "product_id" bigint,
    "serving_basis" "text",
    "serving_amount_g_ml" numeric
);


ALTER TABLE "public"."servings" OWNER TO "postgres";


ALTER TABLE "public"."servings" ALTER COLUMN "serving_id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."servings_serving_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."sources" (
    "source_id" bigint NOT NULL,
    "brand" "text",
    "source_type" "text",
    "ref" "text",
    "url" "text",
    "notes" "text"
);


ALTER TABLE "public"."sources" OWNER TO "postgres";


CREATE OR REPLACE VIEW "public"."v_master" AS
 SELECT "p"."product_id",
    "p"."country",
    "p"."brand",
    "p"."product_type",
    "p"."category",
    "p"."product_name",
    "n"."calories",
    "n"."total_fat_g",
    "n"."saturated_fat_g",
    "n"."trans_fat_g",
    "n"."carbs_g",
    "n"."sugars_g",
    "n"."fibre_g",
    "n"."protein_g",
    "n"."salt_g",
    "s"."unhealthiness_score",
    "s"."healthiness_score",
    "s"."nutri_score_label",
    "s"."processing_risk",
    "s"."nova_classification",
    "s"."high_salt_flag",
    "s"."high_sugar_flag",
    "s"."high_sat_fat_flag",
    "s"."high_additive_load",
    "p"."oil_method",
    "p"."ingredient_complexity",
    "p"."controversies",
    "p"."eu_notes"
   FROM ((("public"."products" "p"
     LEFT JOIN "public"."servings" "sv" ON (("sv"."product_id" = "p"."product_id")))
     LEFT JOIN "public"."nutrition_facts" "n" ON ((("n"."product_id" = "p"."product_id") AND ("n"."serving_id" = "sv"."serving_id"))))
     LEFT JOIN "public"."scores" "s" ON (("s"."product_id" = "p"."product_id")));


ALTER VIEW "public"."v_master" OWNER TO "postgres";


ALTER TABLE ONLY "public"."ingredients"
    ADD CONSTRAINT "ingredients_pkey" PRIMARY KEY ("product_id");



ALTER TABLE ONLY "public"."nutrition_facts"
    ADD CONSTRAINT "nutrition_facts_pkey" PRIMARY KEY ("product_id", "serving_id");



ALTER TABLE ONLY "public"."products"
    ADD CONSTRAINT "products_pkey" PRIMARY KEY ("product_id");



ALTER TABLE ONLY "public"."scores"
    ADD CONSTRAINT "scores_pkey" PRIMARY KEY ("product_id");



ALTER TABLE ONLY "public"."servings"
    ADD CONSTRAINT "servings_pkey" PRIMARY KEY ("serving_id");



ALTER TABLE ONLY "public"."sources"
    ADD CONSTRAINT "sources_pkey" PRIMARY KEY ("source_id");



CREATE INDEX "ingredients_product_id_idx" ON "public"."ingredients" USING "btree" ("product_id");



CREATE UNIQUE INDEX "products_country_brand_name_uniq" ON "public"."products" USING "btree" ("country", "brand", "product_name");



ALTER TABLE ONLY "public"."ingredients"
    ADD CONSTRAINT "ingredients_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("product_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."nutrition_facts"
    ADD CONSTRAINT "nutrition_facts_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("product_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."nutrition_facts"
    ADD CONSTRAINT "nutrition_facts_serving_id_fkey" FOREIGN KEY ("serving_id") REFERENCES "public"."servings"("serving_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."scores"
    ADD CONSTRAINT "scores_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("product_id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."servings"
    ADD CONSTRAINT "servings_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("product_id") ON DELETE CASCADE;





DO $$
BEGIN
    IF EXISTS (
        SELECT 1 FROM pg_catalog.pg_publication WHERE pubname = 'supabase_realtime'
    ) THEN
        ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";
    END IF;
END
$$;


GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";








































































































































































GRANT ALL ON TABLE "public"."ingredients" TO "anon";
GRANT ALL ON TABLE "public"."ingredients" TO "authenticated";
GRANT ALL ON TABLE "public"."ingredients" TO "service_role";



GRANT ALL ON TABLE "public"."nutrition_facts" TO "anon";
GRANT ALL ON TABLE "public"."nutrition_facts" TO "authenticated";
GRANT ALL ON TABLE "public"."nutrition_facts" TO "service_role";



GRANT ALL ON TABLE "public"."products" TO "anon";
GRANT ALL ON TABLE "public"."products" TO "authenticated";
GRANT ALL ON TABLE "public"."products" TO "service_role";



GRANT ALL ON SEQUENCE "public"."products_product_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."products_product_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."products_product_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."scores" TO "anon";
GRANT ALL ON TABLE "public"."scores" TO "authenticated";
GRANT ALL ON TABLE "public"."scores" TO "service_role";



GRANT ALL ON TABLE "public"."servings" TO "anon";
GRANT ALL ON TABLE "public"."servings" TO "authenticated";
GRANT ALL ON TABLE "public"."servings" TO "service_role";



GRANT ALL ON SEQUENCE "public"."servings_serving_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."servings_serving_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."servings_serving_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."sources" TO "anon";
GRANT ALL ON TABLE "public"."sources" TO "authenticated";
GRANT ALL ON TABLE "public"."sources" TO "service_role";



GRANT ALL ON TABLE "public"."v_master" TO "anon";
GRANT ALL ON TABLE "public"."v_master" TO "authenticated";
GRANT ALL ON TABLE "public"."v_master" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";































